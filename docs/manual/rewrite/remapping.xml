<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE manualpage SYSTEM "../style/manualpage.dtd">
<?xml-stylesheet type="text/xsl" href="../style/manual.en.xsl"?>
<!-- $LastChangedRevision: 832069 $ -->

<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<manualpage metafile="remapping.xml.meta">
  <parentdocument href="./">Rewrite</parentdocument>

<title>Redirecting and Remapping with mod_rewrite</title>

<summary>

<p>This document supplements the <module>mod_rewrite</module> 
<a href="../mod_rewrite.html">reference documentation</a>. It describes
how you can use <module>mod_rewrite</module> to redirect and remap
request. This includes many examples of common uses of mod_rewrite,
including detailed descriptions of how each works.</p>

<note type="warning">Note that many of these examples won't work unchanged in your
particular server configuration, so it's important that you understand
them, rather than merely cutting and pasting the examples into your
configuration.</note>

</summary>
<seealso><a href="../mod/mod_rewrite.html">Module documentation</a></seealso>
<seealso><a href="intro.html">mod_rewrite introduction</a></seealso>

<section id="old-to-new">

  <title>From Old to New (internal)</title>

  <dl>
    <dt>Description:</dt>

    <dd>
      <p>Assume we have recently renamed the page
      <code>foo.html</code> to <code>bar.html</code> and now want
      to provide the old URL for backward compatibility. However,
      we want that users of the old URL even not recognize that
      the pages was renamed - that is, we don't want the address to
      change in their browser.</p>
    </dd>

    <dt>Solution:</dt>

    <dd>
      <p>We rewrite the old URL to the new one internally via the
      following rule:</p>

<example><pre>
RewriteEngine  on
RewriteRule    ^<strong>/old</strong>\.html$  <strong>/new</strong>.html [PT]
</pre></example>
    </dd>
  </dl>

</section>

<section id="old-to-new-extern">

  <title>Rewriting From Old to New (external)</title>

  <dl>
    <dt>Description:</dt>

    <dd>
      <p>Assume again that we have recently renamed the page
      <code>foo.html</code> to <code>bar.html</code> and now want
      to provide the old URL for backward compatibility. But this
      time we want that the users of the old URL get hinted to
      the new one, i.e. their browsers Location field should
      change, too.</p>
    </dd>

    <dt>Solution:</dt>

    <dd>
      <p>We force a HTTP redirect to the new URL which leads to a
      change of the browsers and thus the users view:</p>

<example><pre>
RewriteEngine  on
RewriteRule    ^<strong>/foo</strong>\.html$  <strong>bar</strong>.html  [<strong>R</strong>]
</pre></example>
</dd>

<dt>Discussion</dt>

    <dd>
    <p>In this example, as contrasted to the <a
    href="#old-to-new-intern">internal</a> example above, we can simply
    use the Redirect directive. mod_rewrite was used in that earlier
    example in order to hide the redirect from the client:</p>

    <example>
    Redirect /foo.html /bar.html
    </example>

    </dd>
  </dl>

</section>

<section id="static-to-dynamic">

  <title>From Static to Dynamic</title>

  <dl>
    <dt>Description:</dt>

    <dd>
      <p>How can we transform a static page
      <code>foo.html</code> into a dynamic variant
      <code>foo.cgi</code> in a seamless way, i.e. without notice
      by the browser/user.</p>
    </dd>

    <dt>Solution:</dt>

    <dd>
      <p>We just rewrite the URL to the CGI-script and force the
      handler to be <strong>cgi-script</strong> so that it is
      executed as a CGI program.
      This way a request to <code>/~quux/foo.html</code>
      internally leads to the invocation of
      <code>/~quux/foo.cgi</code>.</p>

<example><pre>
RewriteEngine  on
RewriteBase    /~quux/
RewriteRule    ^foo\.<strong>html</strong>$  foo.<strong>cgi</strong>  [H=<strong>cgi-script</strong>]
</pre></example>
    </dd>
  </dl>

</section>

<section id="backward-compatibility">

  <title>Backward Compatibility for file extension change</title>

  <dl>
    <dt>Description:</dt>

    <dd>
      <p>How can we make URLs backward compatible (still
      existing virtually) after migrating <code>document.YYYY</code>
      to <code>document.XXXX</code>, e.g. after translating a
      bunch of <code>.html</code> files to <code>.php</code>?</p>
    </dd>

    <dt>Solution:</dt>

    <dd>
      <p>We rewrite the name to its basename and test for
      existence of the new extension. If it exists, we take
      that name, else we rewrite the URL to its original state.</p>

<example><pre>
#   backward compatibility ruleset for
#   rewriting document.html to document.php
#   when and only when document.php exists
RewriteEngine on

RewriteCond $1.php -f
RewriteCond $1.html !-f
RewriteRule ^(.*).html$ $1.php 
</pre></example>
    </dd>

    <dt>Discussion</dt>
    <dd>
    <p>This example uses an often-overlooked feature of mod_rewrite,
    by taking advantage of the order of execution of the ruleset. In
    particular, mod_rewrite evaluates the left-hand-side of the
    RewriteRule before it evaluates the RewriteCond directives.
    Consequently, $1 is already defined by the time the RewriteRule
    directives are evaluated. This allows us to test for the existence
    of the the original (<code>document.html</code>) and target
    (<code>document.php</code>) files using the same base filename.</p>
    </dd>
  </dl>

</section>

<section id="canonicalhost"><title>Canonical Hostnames</title>

      <dl>
        <dt>Description:</dt>

        <dd>The goal of this rule is to force the use of a particular
        hostname, in preference to other hostnames which may be used to
        reach the same site. For example, if you wish to force the use
        of <strong>www.example.com</strong> instead of
        <strong>example.com</strong>, you might use a variant of the
        following recipe.</dd>

        <dt>Solution:</dt>

        <dd>
<p>For sites running on a port other than 80:</p>
<example><pre>
RewriteCond %{HTTP_HOST}   !^www\.example\.com [NC]
RewriteCond %{HTTP_HOST}   !^$
RewriteCond %{SERVER_PORT} !^80$
RewriteRule ^/?(.*)         http://www.example.com:%{SERVER_PORT}/$1 [L,R,NE]
</pre></example>

<p>And for a site running on port 80</p>
<example><pre>
RewriteCond %{HTTP_HOST}   !^www\.example\.com [NC]
RewriteCond %{HTTP_HOST}   !^$
RewriteRule ^/?(.*)         http://www.example.com/$1 [L,R,NE]
</pre></example>

        <p>
        If you wanted to do this generically for all domain names - that
        is, if you want to redirect <strong>example.com</strong> to
        <strong>www.example.com</strong> for all possible values of
        <strong>example.com</strong>, you could use the following
        recipe:</p>

<example><pre>
RewriteCond %{HTTP_HOST} !^www\. [NC]
RewriteCond %{HTTP_HOST} !^$
RewriteRule ^/?(.*) http://www.%{HTTP_HOST}/$1 [L,R,NE]
</pre></example>

    <p>These rulesets will work either in your main server configuration
    file, or in a <code>.htaccess</code> file placed in the <directive
    module="core">DocumentRoot</directive> of the server.</p>
        </dd>
      </dl>

</section>

<section id="multipledirs">

  <title>Search for pages in more than one directory</title>

  <dl>
    <dt>Description:</dt>

    <dd>
      <p>A particular resource might exist in one of several places, and
      we want to look in those places for the resource when it is
      requested. Perhaps we've recently rearranged our directory
      structure, dividing content into several locations.</p>
    </dd>

    <dt>Solution:</dt>

    <dd>
      <p>The following ruleset searches in two directories to find the
      resource, and, if not finding it in either place, will attempt to
      just serve it out of the location requested.</p>

<example><pre>
RewriteEngine on

#   first try to find it in dir1/...
#   ...and if found stop and be happy:
RewriteCond         %{DOCUMENT_ROOT}/<strong>dir1</strong>/%{REQUEST_URI}  -f
RewriteRule  ^(.+)  %{DOCUMENT_ROOT}/<strong>dir1</strong>/$1  [L]

#   second try to find it in dir2/...
#   ...and if found stop and be happy:
RewriteCond         %{DOCUMENT_ROOT}/<strong>dir2</strong>/%{REQUEST_URI}  -f
RewriteRule  ^(.+)  %{DOCUMENT_ROOT}/<strong>dir2</strong>/$1  [L]

#   else go on for other Alias or ScriptAlias directives,
#   etc.
RewriteRule   ^(.+)  -  [PT]
</pre></example>
    </dd>
  </dl>

</section>

</manualpage> 
